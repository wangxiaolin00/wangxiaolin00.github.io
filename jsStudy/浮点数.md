# 浮点数的表示

* 浮点数一般使用8字节即64bit存储，为双精度浮点数
  * 也有用4字节即32bit存储的单精度浮点数
* 最左边一位表示符号，0表示正，1表示负
* 接下来的11bit表示指数
* 剩余的表示科学记数法中的小数部分，不含整数部分，因为整数部分总是1

* 为什么指数的范围是-1023到1024而非-1024到1023？
  * 指数部分并没有使用补码进行存储
  * 正1024次方表示无穷大
* 为什么指数部分读出时要减1023，写入时要加1023？
  * 指数部分使用原码，范围是0到2047
  * 表示-1023到1024
  * 所以0表示-1023
  * 所以读出时减，写入时加
* 为什么指数不用补码？
  * 为了能够从左往右扫描即可确定两个浮点数的大小
  * 即除符号位以外只看指数部分即可以确定大小
    * 即指数部分谁先出现1谁更大
    * 如果指数部分完全相同，那么底数部分谁先出现1谁更大
* 为什么要如此在意浮点大小对比的效率？
  * 因为浮点数更多时候是对比大小而非对比相等
    * 因为浮点数表示的不精确
      * 很难保证数学上相等的两个计算路径在程序中的计算结果也是完全相同的
        * 在程序中 a * b / c 的结果跟 a / c * b 有可能不相同的
        * 所以在程序中很少判断两个浮点数的相等
          * 而是判断它们在数轴上的距离，即求其差的绝对值看是否小于某个精度
            * Math.abs(a - b) < Number.EPLSION
* 为什么不把底数的整数部分存储？
  * 因为底数的整数部分总是1
  * 效果就是二进制状态下的有效位数是53位
* 正因为有效位数有53位，如果用这53位全部分表示整数
  * 即2的53次方，可以保证在这个范围内的整数运算的精确
  * 所以有一个常量Number.MAX_SAFE_INTEGER的值即为2的53减1
  * 大于这个范围的数不是不能表示，只是不保证完全精确
    * 大于这个范围无法表示浮点数，且整数也不是连续表示的
* 因为总的有效数字只有53位
  * 所以如果整数部分使用的越多，小数部分就越小，反之亦然
  * 而数值越大，整数部分需要的有效位数就越多，而小数部分的有效位数就越少
    * 即数值越大，小数部分的精度就越低
  * 而数值越小，整数部分需要的有效位数就越少，而小数部分的有效位数就越多
    * 即数值越小，小数部分的精度就越高
* IEEE754
  * 单精度浮点数 float   float32   f32
    * 使用4字节表示，其指数部分8bit，底数23bit
  * 双精度浮点数 double  float64   f64
    * 使用8字节表示，指数部分11bit，底数52bit